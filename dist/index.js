class Event{isFunction(functionToCheck){return functionToCheck&&{}.toString.call(functionToCheck)==='[object Function]'}trigger(name,...args){const events=this._events!=null?this._events[name]:undefined;if(events!=null){this._triggerEvents(events,...Array.from(args))}const allEvents=this._events!=null?this._events.all:undefined;if(allEvents!=null){this._triggerEvents(allEvents,name,...Array.from(args))}return this}on(names,callback){if(this._events==null){this._events={}}if(!this.isFunction(callback)){throw new Error('Must have a valid function callback')}if(/\s/g.test(name)){throw new Error('Illegal event name')}const nameArray=names.split(' ');for(var name of Array.from(nameArray)){const events=this._events[name]||(this._events[name]=[]);events.push({callback:callback,self:this})}return this}off(name,callback){if(this._events==null){this._events={}}if(callback==null){this._events={};return this}for(name of Array.from(name.split(' '))){const events=this._events[name]!=null?this._events[name]:[];const names=name?[name]:Array.from(this._events);for(name of Array.from(names)){const newEvents=[];this._events[name]=newEvents;for(let event of Array.from(events)){if(callback!==event.callback){newEvents.push(event)}}if(newEvents.length===0){delete this._events[name]}}}return this}_triggerEvents(events,...args){return Array.from(events).map(event=>event.callback(...Array.from(args||[])))}}class WebsocketConnection{constructor(host,log){this.host=host;this.log=log;this.events=new Event;this.readyState=0}on(eventName,cb){this.events.on(eventName,cb)}off(eventName,cb){this.events.off(eventName,cb)}connect(){this.readyState=0;const connection=new WebSocket(this.host);connection.binaryType='arraybuffer';connection.onopen=(()=>this._onOpen());connection.onclose=(()=>this._onClose());connection.onerror=(e=>this._onError(e));connection.onmessage=(e=>this._onMessage(e));return this.connection=connection}close(){return this.connection.close()}send(payload){const isCorrectType=payload instanceof Uint8Array||payload instanceof Blob;if(!isCorrectType){console.error('Payload to send() must be Uint8Array or blob');return}return this.connection.send(payload)}_onMessage(event){return this.events.trigger('message',event.data)}_onOpen(event){this.log.log('flux: opened');this.readyState=1;return this.events.trigger('open',this)}_onClose(event){this.log.log('flux: closed');this.readyState=2;return this.events.trigger('close',this)}_onError(error){if(this.log!=null){this.log.log('flux: we have a error:',error)}return this.events.trigger('error',this)}}export{WebsocketConnection};